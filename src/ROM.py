'''
This file makes use of `myhdl` to do RTL-level design.
'''

from myhdl import *

def Divisors_ROM(addr, dout):
    ''' This ROM records the divisors for numbers ranging from 1~63 '''
    ROM = (
        0B0000000000000000000000000000000000000000000000000000000000000000, #0
        0B0000000000000000000000000000000000000000000000000000000000000010, #1
        0B0000000000000000000000000000000000000000000000000000000000000110, #2
        0B0000000000000000000000000000000000000000000000000000000000001010, #3
        0B0000000000000000000000000000000000000000000000000000000000010110, #4
        0B0000000000000000000000000000000000000000000000000000000000100010, #5
        0B0000000000000000000000000000000000000000000000000000000001001110, #6
        0B0000000000000000000000000000000000000000000000000000000010000010, #7
        0B0000000000000000000000000000000000000000000000000000000100010110, #8
        0B0000000000000000000000000000000000000000000000000000001000001010, #9
        0B0000000000000000000000000000000000000000000000000000010000100110, #10
        0B0000000000000000000000000000000000000000000000000000100000000010, #11
        0B0000000000000000000000000000000000000000000000000001000001011110, #12
        0B0000000000000000000000000000000000000000000000000010000000000010, #13
        0B0000000000000000000000000000000000000000000000000100000010000110, #14
        0B0000000000000000000000000000000000000000000000001000000000101010, #15
        0B0000000000000000000000000000000000000000000000010000000100010110, #16
        0B0000000000000000000000000000000000000000000000100000000000000010, #17
        0B0000000000000000000000000000000000000000000001000000001001001110, #18
        0B0000000000000000000000000000000000000000000010000000000000000010, #19
        0B0000000000000000000000000000000000000000000100000000010000110110, #20
        0B0000000000000000000000000000000000000000001000000000000010001010, #21
        0B0000000000000000000000000000000000000000010000000000100000000110, #22
        0B0000000000000000000000000000000000000000100000000000000000000010, #23
        0B0000000000000000000000000000000000000001000000000001000101011110, #24
        0B0000000000000000000000000000000000000010000000000000000000100010, #25
        0B0000000000000000000000000000000000000100000000000010000000000110, #26
        0B0000000000000000000000000000000000001000000000000000001000001010, #27
        0B0000000000000000000000000000000000010000000000000100000010010110, #28
        0B0000000000000000000000000000000000100000000000000000000000000010, #29
        0B0000000000000000000000000000000001000000000000001000010001101110, #30
        0B0000000000000000000000000000000010000000000000000000000000000010, #31
        0B0000000000000000000000000000000100000000000000010000000100010110, #32
        0B0000000000000000000000000000001000000000000000000000100000001010, #33
        0B0000000000000000000000000000010000000000000000100000000000000110, #34
        0B0000000000000000000000000000100000000000000000000000000010100010, #35
        0B0000000000000000000000000001000000000000000001000001001001011110, #36
        0B0000000000000000000000000010000000000000000000000000000000000010, #37
        0B0000000000000000000000000100000000000000000010000000000000000110, #38
        0B0000000000000000000000001000000000000000000000000010000000001010, #39
        0B0000000000000000000000010000000000000000000100000000010100110110, #40
        0B0000000000000000000000100000000000000000000000000000000000000010, #41
        0B0000000000000000000001000000000000000000001000000100000011001110, #42
        0B0000000000000000000010000000000000000000000000000000000000000010, #43
        0B0000000000000000000100000000000000000000010000000000100000010110, #44
        0B0000000000000000001000000000000000000000000000001000001000101010, #45
        0B0000000000000000010000000000000000000000100000000000000000000110, #46
        0B0000000000000000100000000000000000000000000000000000000000000010, #47
        0B0000000000000001000000000000000000000001000000010001000101011110, #48
        0B0000000000000010000000000000000000000000000000000000000010000010, #49
        0B0000000000000100000000000000000000000010000000000000010000100110, #50
        0B0000000000001000000000000000000000000000000000100000000000001010, #51
        0B0000000000010000000000000000000000000100000000000010000000010110, #52
        0B0000000000100000000000000000000000000000000000000000000000000010, #53
        0B0000000001000000000000000000000000001000000001000000001001001110, #54
        0B0000000010000000000000000000000000000000000000000000100000100010, #55
        0B0000000100000000000000000000000000010000000000000100000110010110, #56
        0B0000001000000000000000000000000000000000000010000000000000001010, #57
        0B0000010000000000000000000000000000100000000000000000000000000110, #58
        0B0000100000000000000000000000000000000000000000000000000000000010, #59
        0B0001000000000000000000000000000001000000000100001001010001111110, #60
        0B0010000000000000000000000000000000000000000000000000000000000010, #61
        0B0100000000000000000000000000000010000000000000000000000000000110, #62
        0B1000000000000000000000000000000000000000001000000000001010001010  #63
    )

    @always_comb
    def access_ROM():
        dout.next = ROM[int(addr)]

    return access_ROM

#Simulation:
if __name__ == '__main__':
    def testbench():
        addr = Signal(intbv(0)[8:])  # 8 bits address
        dout = Signal(intbv(0)[64:]) # 64 bits data

        ROM = Divisors_ROM(addr, dout)

        def get_divisors(n):
            row = 0
            for i in xrange(1, n+1, 1):
                if n % i == 0:
                    row += 2**i
            return row

        @instance
        def tester():
            for n in xrange(64):
                addr.next = n
                yield delay(1)
                print 'int:', str(now()-1).rjust(2),
                print 'exp:', str(bin(get_divisors(n))).rjust(64, str(0)),
                print 'got:', str(bin(dout)).rjust(64, str(0))
                assert dout == get_divisors(n)

        return ROM, tester

    sim = Simulation(testbench())
    sim.run()
